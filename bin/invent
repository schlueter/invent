#!/usr/bin/env node

var program = require('commander');
var mkdirp = require('mkdirp');
var tar = require('tar');

var os = require('os');
var fs = require('fs');
var path = require('path');
var https = require('https');
var zlib = require('zlib');

var pkg = require('../package.json');
var version = pkg.version;
var eol = os.EOL

program
  .version(version)
  .usage('[options] [destination]')
  .option('-f, --force', 'force on non-empty destination')
  .parse(process.argv);

var destinationPath = program.args.shift() || '.';
var appName = program.args.shift() || 'invent';
var cookbookPath = path.join(destinationPath, 'cookbooks');
var templatePath = path.join(__dirname, '..', 'templates');

(function createApplication(applicationPath) {
  isEmpty(applicationPath, function(empty){
    if (empty || program.force) {
      createApplicationAt(applicationPath);
    } else {
      program.confirm('destination folder is not empty, continue? (y/n) ', function(ok){
        if (ok) {
          process.stdin.destroy();
          createApplicationAt(applicationPath);
        } else {
          abort('aborting');
        }
      });
    }
  });
})(destinationPath);

/**
 * Create application at the given directory `applicationPath`.
 *
 * @param {String} applicationPath
 */

function createApplicationAt(applicationPath) {
  process.on('exit', function(){
    console.log();
    console.log('   getting started :');
    console.log('     $ cd ' + applicationPath + ' && vagrant up');
    console.log('     $ vagrant ssh');
    console.log();
    console.log('   \x1b[36mstart inventing ;)\x1b[0m');
    console.log();
  });

  mkdir(applicationPath, function(){
    writeTemplate('Vagrantfile');
    writeTemplate('package.json');
    downloadCookbooks();
  });
}

/**
 * Writes the specified templates
 *
 * @param {String} template
 */

function writeTemplate(template) {
  var templateContent = fs.readFileSync(path.join(templatePath, template), 'utf-8').replace('{appName}', appName);
  write(path.join(destinationPath, template), templateContent);
} 

/**
 * Check if the given directory `path` is empty.
 *
 * @param {String} path
 * @param {Function} fn
 */

function isEmpty(path, fn) {
  fs.readdir(path, function(err, files){
    if (err && 'ENOENT' != err.code) {
      throw err;
    }
    fn(!files || !files.length);
  });
}

/**
 * echo str > path.
 *
 * @param {String} path
 * @param {String} str
 * @param {String} mode
 */

function write(path, str, mode) {
  fs.writeFile(path, str, { mode: mode || 0666 });
  console.log('   \x1b[36mcreated\x1b[0m    : ' + path);
}

/**
 * Mkdir -p.
 *
 * @param {String} path
 * @param {Function} fn
 */

function mkdir(path, fn) {
  mkdirp(path, 0755, function(err){
    if (err) {
      throw err;
    }
    console.log('   \033[36mcreated\033[0m    : ' + path);
    fn && fn();
  });
}

/**
 * Download cookbooks specified in config/cookbooks.json and extract into 
 * destinationPath/cookbooks
 *
 */

function downloadCookbooks() {
  mkdir(path.join(destinationPath, 'cookbooks'));
  var cookbookList = require(path.join(__dirname, '..', 'config', 'cookbooks.json'));
  for(var book in cookbookList) {
    download(cookbookList[book], path.join(cookbookPath, book + '.tar.gz'), function(error, _path) {
      if(!error) {
        extract(_path, cookbookPath, function(extractError, _destination) {
          if(extractError) {
            console.log('extractError', extractError);
          } else {
            cleanup(_destination, _path);
          }
        });
      } else {
        // console.error('Error downloading', cookbookList[book]);
        abort('Error downloading ' + cookbookList[book]);
      }
    });
  }
}

/**
 * Cleanups up cookbooks
 *
 * @param {String} source
 * @param {String} destination
 */

function cleanup(source, destination) {  
  source = path.join(cookbookPath, source);
  fs.unlink(destination, function(error) {
    if(error) {
      // console.error('Error unlinking', destination);
      abort('Error unlinking ' + destination);
    }
  });
  fs.rename(source, destination.replace('.tar.gz', ''), function(error) {
    if(error) {
      // console.error('Error renaming', source, 'to', destination.replace('.tar.gz', ''));
      abort('Error renaming ' + source + ' to ' + destination.replace('.tar.gz', ''));
    }
  });
}

/**
 * Extract a tar.gz file
 *
 * @param {String} source
 * @param {String} destination
 * @param {String} cb
 */
function extract(source, destination, cb) {
  var filename = '';
  fs.createReadStream(source)
    .pipe(zlib.createGunzip())
    .pipe(tar.Extract({ path : destination }))
    error('error', function(error) { cb(error, destination); })
    .once('entry', function(entry) { filename = entry.path.substring(0, entry.path.length -1); })
    .on('end', function() { cb(null, filename); })
}

/**
 * Download a file (tar.gz) via https module
 *
 * @param {String} url
 * @param {String} path
 * @param {String} cb
 */
function download(url, path, cb) {
  https.get(url, function(response) {
    var data = [], dataLen = 0; 
    var headers = JSON.stringify(response.headers);
    switch(response.statusCode) {
      case 200 :
        var file = fs.createWriteStream(path);
        response.pipe(file);
        response.on('end', function() {
          console.log('   \033[36mdownloaded\033[0m : ' + path.replace('.tar.gz', ''));
          cb(null, path);
        });
        break;
      case 301 :
      case 302 :
      case 303 :
      case 307 :
        download(response.headers.location, path, cb);
        break;
      default :
        // cb(new Error('Server responded with status code ' + response.statusCode), path);
        abort('Server responded with status code ' + response.statusCode + ' | ' + path)
    }
  })
  .on('error', function(err) {
    cb(err, null);
  });
}

/**
 * Exit with the given `str`.
 *
 * @param {String} str
 */

function abort(str) {
  console.error(str);
  process.exit(1);
}
